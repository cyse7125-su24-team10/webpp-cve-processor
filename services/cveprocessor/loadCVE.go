package cveprocessor

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"github.com/cyse7125-su24-team10/webpp-cve-processor/types" // Import the missing package "types"
	"github.com/segmentio/kafka-go"
)

type LoadCVE struct {
}

func NewLoadCVE() *LoadCVE {
	return &LoadCVE{}
}

func (l *LoadCVE) LoadJsonData(w *kafka.Writer) (string, error) {
	cnt := 0

	entries, err := os.ReadDir("./cvelistV5-main")
	if err != nil {
		log.Fatal(err)
	}

	for _, e := range entries {
		// Skip files in the root directory (./cvelistV5-main)
		if !e.IsDir() {
			continue
		}
		dir, err := os.ReadDir("./cvelistV5-main/" + e.Name())
		if err != nil {
			log.Fatal(err)
		}
		for _, d := range dir {
			if !d.IsDir() {
				continue
			}
			year, err := os.ReadDir("./cvelistV5-main/" + e.Name() + "/" + d.Name())
			if err != nil {
				log.Fatal(err)
			}
			for _, o := range year {
				folder, err := os.ReadDir("./cvelistV5-main/" + e.Name() + "/" + d.Name() + "/" + o.Name())
				if err != nil {
					log.Fatal(err)
				}
				filePath := fmt.Sprintf("./cvelistV5-main/" + e.Name() + "/" + d.Name() + "/" + o.Name())
				for _, f := range folder {
					l.PushtoKafka(w, f, filePath)
					cnt++
					//fmt.Println(f, filePath)
				}

			}
		}
	}

	fmt.Println(cnt)
	return "cnt", nil
}

func (l *LoadCVE) PushtoKafka(w *kafka.Writer, file os.DirEntry, filePath string) (string, error) {
	jsonFilePath := fmt.Sprintf("%s/%s", filePath, file.Name())
	jsonData, err := os.ReadFile(jsonFilePath)
	if err != nil {
		log.Fatal(err)
	}

	parsedCVEData := GetCVEData(jsonData)
	pasedCVEID := GetCVEID(parsedCVEData)

	fmt.Println(pasedCVEID.CveID)
	kafkaPush := NewKafkaProducer()
	pushMessage, err := kafkaPush.PushMessage(w, pasedCVEID.CveID, string(jsonData))
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(pushMessage)
	return "Data inserted successfully", nil
}

// func (l *LoadCVE) InsertDB(file os.DirEntry, filePath string) (string, error) {
// 	jsonFilePath := fmt.Sprintf("%s/%s", filePath, file.Name())
// 	jsonData, err := os.ReadFile(jsonFilePath)
// 	if err != nil {
// 		log.Fatal(err)
// 	}

// 	parsedCVEData := GetCVEData(jsonData)
// 	pasedCVEID := GetCVEID(parsedCVEData)

// 	fmt.Println(pasedCVEID.CveID)

// 	// SQL query to insert data, avoiding duplicates based on cveId in cve_metadata
// 	query := "INSERT INTO cve.CVE (id, datatype, dataversion, cve_metadata, containers) VALUES ($1, $2, $3, $4::jsonb, $5::jsonb) ON CONFLICT (id) DO NOTHING;"

// 	// Execute the SQL query
// 	_, err = l.db.Exec(query, pasedCVEID.CveID, parsedCVEData.DataType, parsedCVEData.DataVersion, parsedCVEData.CveMetadata, parsedCVEData.Containers)
// 	if err != nil {
// 		return "", fmt.Errorf("failed to insert data: %v", err)
// 	}

// 	return "Data inserted successfully", nil
// }

func GetCVEData(jsonData []byte) types.CVEData {
	var cveData types.CVEData
	err := json.Unmarshal(jsonData, &cveData)
	if err != nil {
		log.Fatal(err)
	}
	return cveData
}

func GetCVEID(parsedCVEData types.CVEData) types.CveMetadataID {
	var cveId types.CveMetadataID
	err := json.Unmarshal(parsedCVEData.CveMetadata, &cveId)
	if err != nil {
		log.Fatal(err)
	}
	return cveId
}
